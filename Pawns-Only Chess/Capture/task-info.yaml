type: edu
files:
- name: src/chess/Main.kt
  visible: true
  text: |-
    package chess

    class ChessBoard() {
        private val boardSize: Int = 8

        class Square() {
            var piece: String = " "
        }

        // define the double array that holds all the squares.  A few variations.
        // val board = MutableList(boardSize) { MutableList(boardSize) { Square() } }
        // val board = Array(boardSize) { row -> Array(boardSize) { col -> Square() } }
        private val board = Array(boardSize) { Array(boardSize) { Square() } }

        init {
            resetBoard()
        }

        fun resetBoard() {
            // setup the board to start a new game
            for (x in 0 until boardSize) {
                board[6][x].piece = "B"
                board[1][x].piece = "W"
            }
        }

        fun movePiece(player: Player, fromX: Int, fromY: Int, toX: Int, toY: Int): Int {
            if ((fromX < 0 || fromX >= boardSize) ||
                (fromY < 0 || fromY >= boardSize) ||
                (toX < 0 || toX >= boardSize) ||
                (toY < 0 || toY >= boardSize)
            )
                return 0

            board[toX][toY].piece = board[fromX][fromY].piece
            board[fromX][fromY].piece = " "
            return 1
        }

        fun movePiece(player: Player, fromCoord: String, toCoord: String): Int {
            if (fromCoord.length != 2 || toCoord.length != 2 || fromCoord == toCoord)
                return 0

            val fromXY: List<Int> = convertCoords(fromCoord)
            val toXY: List<Int> = convertCoords(toCoord)

            return movePiece(player, fromXY[0], fromXY[1], toXY[0], toXY[1])
        }

        fun movePiece(player: Player, coord: String): Int {
            if (coord.length != 4)
                return 0

            return movePiece(player, coord.substring(0, 2), coord.substring(2, 4))
        }

        fun getPiece(coord: String): String {
            if (coord.length != 2)
                return ""

            val fromXY: List<Int> = convertCoords(coord)
            return board[fromXY[0]][fromXY[1]].piece
        }

        private fun convertCoords(position: String): List<Int> {
            if (position[0].isLetter() == false || position[1].isDigit() == false)
                return listOf(-1, -1) // trigger an error

            return listOf(position[1].digitToInt() - 1, position.uppercase()[0] - 'A')
        }

        fun print() {
            println("  +---+---+---+---+---+---+---+---+")

            for (x in board.size - 1 downTo 0) {
                print("${x + 1} ")
                for (y in 0 until board[x].size)
                    print("| ${board[x][y].piece} ")
                println("|")
                println("  +---+---+---+---+---+---+---+---+")
            }
            println("    a   b   c   d   e   f   g   h ")
        }
    }

    class Player() {
        var name: String = ""
        var color: String = " "
    }

    fun validMove(board: ChessBoard, player: Player, move: String): Int {

        // validate syntax
        if (move.compareTo("[a-zA-Z][1-8][a-zA-Z][1-8]") == 0) {
            println("Invalid Input")
            return 0
        }

        val fromY: Char = move[0]
        val fromX: Int = move[1].digitToInt()
        val toY: Char = move[2]
        val toX: Int = move[3].digitToInt()
        val fromPiece: String = board.getPiece(move.substring(0, 2))
        val toPiece: String = board.getPiece(move.substring(2, 4))

        if (fromPiece != player.color) {
            if (player.color == "W")
                println("No white pawn at ${move.substring(0, 2)}")
            else
                println("No black pawn at ${move.substring(0, 2)}")

            return 0
        }

        // common checks
        if (toPiece != " " ||
            (toX == fromX) ||
            (toY != fromY)
        ) {
            println("Invalid Input")
            return 0
        }

        if (player.color == "W") {
            // can move 1 or 2 places UP
            if ((fromX == 2 && toX !in 3..4) ||
                (fromX != 2 && toX != fromX + 1)
            ) {
                println("Invalid Input")
                return 0
            }
        }

        if (player.color == "B") {
            // can move 1 or 2 places DOWN
            if ((fromX == 7 && toX !in 5..6) ||
                (fromX != 7 && toX != fromX - 1)
            ) {
                println("Invalid Input")
                return 0
            }
        }
        return 1
    }

    fun main() {
        val board = ChessBoard()
        val player = Array(2) { Player() }

        println("Pawns-Only Chess")

        // setup the players
        print("First Player's name: ")
        player[0].name = readln()
        if (player[0].name == "") player[0].name = "Player 1"
        player[0].color = "W"

        print("Second Player's name: ")
        player[1].name = readln()
        if (player[1].name == "") player[1].name = "Player 2"
        player[1].color = "B"

        board.print()

        // setup the game loop
        var command: String = ""
        var playersTurn: Int = 0

        while (command != "exit") {

            print("${player[playersTurn].name}'s turn: ")

            command = readln()

            if (command == "exit")
                continue

            if (command == "print") {
                board.print()
                continue
            }

            if (validMove(board, player[playersTurn], command) == 0) {
                continue
            }

            if (board.movePiece(player[playersTurn], command) == 0) {
                println("Invalid Input")
                continue
            }
            //toggle active player
            board.print()
            playersTurn = playersTurn xor 1
        }
        println("Bye!")
    }
  learner_created: false
- name: test/PawnsOnlyChessTest.kt
  visible: false
  text: |+
    import org.hyperskill.hstest.dynamic.DynamicTest
    import org.hyperskill.hstest.stage.StageTest
    import org.hyperskill.hstest.testcase.CheckResult
    import org.hyperskill.hstest.testing.TestedProgram

    class PawnsOnlyChessTest : StageTest<Any>() {
    // Tests added 11-Nov-21, Start
        @DynamicTest
        fun directCapture1(): CheckResult {
            for (ch in 'a'..'g') {
                val pawnsWhite = MutableList<Pair<Int, Int>>(8) { index -> Pair(1, index) }
                val pawnsBlack = MutableList<Pair<Int, Int>>(8) { index -> Pair(6, index) }

                val main = TestedProgram()
                var outputString = main.start().trim()

                var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
                if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
                position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
                if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

                outputString = main.execute("John").trim()
                position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
                if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

                outputString = main.execute("Amelia").trim()
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
                position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")


                outputString = main.execute("${ch}2${ch}4").trim()
                pawnsWhite.remove(Pair(1, ch - 'h' + 7))
                pawnsWhite.add(Pair(3, ch - 'h' + 7))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
                if (position == -1) return CheckResult(false, "Player 2 prompt to play is expected.")

                outputString = main.execute("${ch + 1}7${ch + 1}5").trim()
                pawnsBlack.remove(Pair(6, ch - 'h' + 8))
                pawnsBlack.add(Pair(4, ch - 'h' + 8))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                if (position == -1) return CheckResult(false, "Player 1 prompt to play is expected.")

                outputString = main.execute("${ch}4${ch + 1}5").trim()
                pawnsWhite.remove(Pair(3, ch - 'h' + 7))
                pawnsBlack.remove(Pair(4, ch - 'h' + 8))
                pawnsWhite.add(Pair(4, ch - 'h' + 8))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after capturing.")
                position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
                if (position == -1) return CheckResult(false, "Player 2 prompt to play is expected.")

                outputString = main.execute("exit").trim()
                position = checkOutput(outputString.toLowerCase(), 0, "bye")
                if ( position  == -1 ) return CheckResult(false, "Exit message is expected.")

                if (!main.isFinished) return CheckResult(false, "The application didn't exit.")
            }

            return CheckResult.correct()
        }

        @DynamicTest
        fun directCapture2(): CheckResult {
            for (ch in 'b'..'h') {
                val pawnsWhite = MutableList<Pair<Int, Int>>(8) { index -> Pair(1, index) }
                val pawnsBlack = MutableList<Pair<Int, Int>>(8) { index -> Pair(6, index) }

                val main = TestedProgram()
                var outputString = main.start().trim()

                var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
                if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
                position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
                if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

                outputString = main.execute("John").trim()
                position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
                if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

                outputString = main.execute("Amelia").trim()
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
                position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")


                outputString = main.execute("${ch}2${ch}4").trim()
                pawnsWhite.remove(Pair(1, ch - 'h' + 7))
                pawnsWhite.add(Pair(3, ch - 'h' + 7))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
                if (position == -1) return CheckResult(false, "Player 2 prompt to play is expected.")

                outputString = main.execute("${ch - 1}7${ch - 1}5").trim()
                pawnsBlack.remove(Pair(6, ch - 'h' + 6))
                pawnsBlack.add(Pair(4, ch - 'h' + 6))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                if (position == -1) return CheckResult(false, "Player 1 prompt to play is expected.")

                outputString = main.execute("${ch}4${ch - 1}5").trim()
                pawnsWhite.remove(Pair(3, ch - 'h' + 7))
                pawnsBlack.remove(Pair(4, ch - 'h' + 6))
                pawnsWhite.add(Pair(4, ch - 'h' + 6))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout capturing.")
                position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
                if (position == -1) return CheckResult(false, "Player 2 prompt to play is expected.")

                outputString = main.execute("exit").trim()
                position = checkOutput(outputString.toLowerCase(), 0, "bye")
                if ( position  == -1 ) return CheckResult(false, "Exit message is expected.")

                if (!main.isFinished) return CheckResult(false, "The application didn't exit.")
            }

            return CheckResult.correct()
        }

        @DynamicTest
        fun directCapture3(): CheckResult {
            for (ch in 'a'..'g') {
                val pawnsWhite = MutableList<Pair<Int, Int>>(8) { index -> Pair(1, index) }
                val pawnsBlack = MutableList<Pair<Int, Int>>(8) { index -> Pair(6, index) }

                val main = TestedProgram()
                var outputString = main.start().trim()

                var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
                if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
                position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
                if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

                outputString = main.execute("John").trim()
                position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
                if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

                outputString = main.execute("Amelia").trim()
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
                position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")


                outputString = main.execute("${ch}2${ch}3").trim()
                pawnsWhite.remove(Pair(1, ch - 'h' + 7))
                pawnsWhite.add(Pair(2, ch - 'h' + 7))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
                position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
                if (position == -1) return CheckResult(false, "Player 2 prompt to play is expected.")

                outputString = main.execute("${ch + 1}7${ch + 1}5").trim()
                pawnsBlack.remove(Pair(6, ch - 'h' + 8))
                pawnsBlack.add(Pair(4, ch - 'h' + 8))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                if (position == -1) return CheckResult(false, "Player 1 prompt to play is expected.")

                outputString = main.execute("${ch}3${ch}4").trim()
                pawnsWhite.remove(Pair(2, ch - 'h' + 7))
                pawnsWhite.add(Pair(3, ch - 'h' + 7))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after a forward move.")
                position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
                if (position == -1) return CheckResult(false, "Player 2 prompt to play is expected.")

                outputString = main.execute("${ch + 1}5${ch}4").trim()
                pawnsBlack.remove(Pair(4, ch - 'h' + 8))
                pawnsWhite.remove(Pair(3, ch - 'h' + 7))
                pawnsBlack.add(Pair(3, ch - 'h' + 7))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after capturing.")
                position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                if (position == -1) return CheckResult(false, "Player 1 prompt to play is expected.")

                outputString = main.execute("exit").trim()
                position = checkOutput(outputString.toLowerCase(), 0, "bye")
                if ( position  == -1 ) return CheckResult(false, "Exit message is expected.")

                if (!main.isFinished) return CheckResult(false, "The application didn't exit.")
            }

            return CheckResult.correct()
        }

        @DynamicTest
        fun directCapture4(): CheckResult {
            for (ch in 'b'..'h') {
                val pawnsWhite = MutableList<Pair<Int, Int>>(8) { index -> Pair(1, index) }
                val pawnsBlack = MutableList<Pair<Int, Int>>(8) { index -> Pair(6, index) }

                val main = TestedProgram()
                var outputString = main.start().trim()

                var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
                if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
                position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
                if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

                outputString = main.execute("John").trim()
                position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
                if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

                outputString = main.execute("Amelia").trim()
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
                position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")


                outputString = main.execute("${ch}2${ch}3").trim()
                pawnsWhite.remove(Pair(1, ch - 'h' + 7))
                pawnsWhite.add(Pair(2, ch - 'h' + 7))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
                position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
                if (position == -1) return CheckResult(false, "Player 2 prompt to play is expected.")

                outputString = main.execute("${ch - 1}7${ch - 1}5").trim()
                pawnsBlack.remove(Pair(6, ch - 'h' + 6))
                pawnsBlack.add(Pair(4, ch - 'h' + 6))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                if (position == -1) return CheckResult(false, "Player 1 prompt to play is expected.")

                outputString = main.execute("${ch}3${ch}4").trim()
                pawnsWhite.remove(Pair(2, ch - 'h' + 7))
                pawnsWhite.add(Pair(3, ch - 'h' + 7))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after a forward move.")
                position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
                if (position == -1) return CheckResult(false, "Player 2 prompt to play is expected.")

                outputString = main.execute("${ch - 1}5${ch}4").trim()
                pawnsBlack.remove(Pair(4, ch - 'h' + 6))
                pawnsWhite.remove(Pair(3, ch - 'h' + 7))
                pawnsBlack.add(Pair(3, ch - 'h' + 7))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after capturing.")
                position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                if (position == -1) return CheckResult(false, "Player 1 prompt to play is expected.")

                outputString = main.execute("exit").trim()
                position = checkOutput(outputString.toLowerCase(), 0, "bye")
                if ( position  == -1 ) return CheckResult(false, "Exit message is expected.")

                if (!main.isFinished) return CheckResult(false, "The application didn't exit.")
            }

            return CheckResult.correct()
        }
    // Tests added 11-Nov-21, End
        @DynamicTest
        fun testAdd4(): CheckResult {
            for (ch in listOf('a', 'c', 'e')) {
                val chList = ('a'..'h').filter {it - ch > 1 }
                for (ch2 in chList) {

                    val pawnsWhite = MutableList<Pair<Int, Int>>(8) { index -> Pair(1, index) }
                    val pawnsBlack = MutableList<Pair<Int, Int>>(8) { index -> Pair(6, index) }

                    val main = TestedProgram()
                    var outputString = main.start().trim()

                    var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
                    if (position == -1) return CheckResult(false, "Program title is expected.")
                    position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
                    if (position == -1) return CheckResult(false, "Player 1 name prompt is expected.")

                    outputString = main.execute("John").trim()
                    position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
                    if (position == -1) return CheckResult(false, "Player 2 name prompt is expected.")

                    outputString = main.execute("Amelia").trim()
                    position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                    if (position == -1) return CheckResult(false, "Wrong initial chessboard printout.")
                    position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                    if (position == -1) return CheckResult(false, "Player 1 prompt to play is expected.")

                    outputString = main.execute("${ch}2${ch}4").trim()
                    pawnsWhite.remove(Pair(1, ch - 'h' + 7))
                    pawnsWhite.add(Pair(3, ch - 'h' + 7))
                    position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                    if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                    position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
                    if (position == -1) return CheckResult(false, "Player 2 prompt to play is expected.")

                    outputString = main.execute("a7a6").trim()
                    pawnsBlack.remove(Pair(6, 0))
                    pawnsBlack.add(Pair(5, 0))
                    position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                    if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                    position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                    if (position == -1) return CheckResult(false, "Player 1 prompt to play is expected.")

                    outputString = main.execute("${ch}4${ch}5").trim()
                    pawnsWhite.remove(Pair(3, ch - 'h' + 7))
                    pawnsWhite.add(Pair(4, ch - 'h' + 7))
                    position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                    if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                    position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
                    if (position == -1) return CheckResult(false, "Player 2 prompt to play is expected.")

                    outputString = main.execute("${ch2}7${ch2}5").trim()
                    pawnsBlack.remove(Pair(6, ch2 - 'h' + 7))
                    pawnsBlack.add(Pair(4, ch2 - 'h' + 7))
                    position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                    if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
                    position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                    if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

                    outputString = main.execute("${ch}5${ch2}6").trim()
                    position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
                    if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

                    outputString = main.execute("${ch}5${ch + 1}6").trim()
                    position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
                    if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

                    outputString = main.execute("exit").trim()
                    position = checkOutput(outputString.toLowerCase(), 0, "bye")
                    if (position == -1) return CheckResult(false, "Exit message is expected.")
                }
            }

            return CheckResult.correct()
        }

        @DynamicTest
        fun testAdd3(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) { index -> Pair(1, index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) { index -> Pair(6, index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            for (ch in 'a'..'h') {
                outputString = main.execute("${ch}2${ch}4").trim()
                pawnsWhite.remove(Pair(1, ch - 'h' + 7))
                pawnsWhite.add(Pair(3, ch - 'h' + 7))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
                if (position == -1) return CheckResult(false, "Player 2 prompt to play is expected.")

                outputString = main.execute("${ch}7${ch}5").trim()
                pawnsBlack.remove(Pair(6, ch - 'h' + 7))
                pawnsBlack.add(Pair(4, ch - 'h' + 7))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                if (position == -1) return CheckResult(false, "Player 1 prompt to play is expected.")
            }

            for (ch in listOf('a', 'e', 'h')) {
                val chList = ('a'..'h').filter { kotlin.math.abs(it - ch) > 1 }
                for (ch2 in chList) {
                    outputString = main.execute("${ch}4${ch2}5").trim()
                    position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
                    if (position == -1) return CheckResult(false, "Incorrect output after an invalid command.")
                }
            }

            outputString = main.execute("exit").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "bye")
            if ( position  == -1 ) return CheckResult(false, "Exit message is expected.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun testAdd2(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) { index -> Pair(1, index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) { index -> Pair(6, index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("a2a4").trim()
            pawnsWhite.remove(Pair(1, 0))
            pawnsWhite.add(Pair(3, 0))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if (position == -1) return CheckResult(false, "Player 2 prompt to play is expected.")

            outputString = main.execute("a7a5").trim()
            pawnsBlack.remove(Pair(6, 0))
            pawnsBlack.add(Pair(4, 0))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if (position == -1) return CheckResult(false, "Player 1 prompt to play is expected.")

            for (ch in 'b'..'h') {
                outputString = main.execute("${ch - 1}4${ch - 1}5").trim()
                position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
                if (position == -1) return CheckResult(false, "Incorrect output after an invalid command.")

                outputString = main.execute("${ch}2${ch}4").trim()
                pawnsWhite.remove(Pair(1, ch - 'h' + 7))
                pawnsWhite.add(Pair(3, ch - 'h' + 7))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
                if (position == -1) return CheckResult(false, "Player 2 prompt to play is expected.")

                outputString = main.execute("${ch - 1}5${ch - 1}4").trim()
                position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "amelia's turn:")
                if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

                outputString = main.execute("${ch}7${ch}5").trim()
                pawnsBlack.remove(Pair(6, ch - 'h' + 7))
                pawnsBlack.add(Pair(4, ch - 'h' + 7))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                if (position == -1) return CheckResult(false, "Player 1 prompt to play is expected.")
            }
            outputString = main.execute("h4h5").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
            if (position == -1) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("exit").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "bye")
            if ( position  == -1 ) return CheckResult(false, "Exit message is expected.")

            return CheckResult.correct()
        }


        @DynamicTest
        fun testAdd1(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) {index -> Pair(1,index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) {index -> Pair(6,index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e2e2").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("d2d1").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("c2c5").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("a2a6").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("g2g7").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("a2a8").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("b3b3").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "no white pawn at b3", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after trying to make a move from a square with no white pawn.")

            outputString = main.execute("c4c4").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "no white pawn at c4", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after trying to make a move from a square with no white pawn.")

            outputString = main.execute("f2f1").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            for (ch in 'a'..'g') {
                outputString = main.execute("${ch}2${ch+1}3").trim()
                position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
                if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")
            }

            outputString = main.execute("h2g3").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("e2e3").trim()
            pawnsWhite.remove(Pair(1, 4))
            pawnsWhite.add(Pair(2, 4))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 prompt to play is expected.")

            for (ch in 'a'..'g') {
                outputString = main.execute("${ch}7${ch+1}6").trim()
                position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "amelia's turn:")
                if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")
            }

            outputString = main.execute("h7g6").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("e7e7").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("b7b8").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("e7e4").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("h7h3").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("g7g2").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("a7a1").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("a6a6").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "no black pawn at a6", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after trying to make a move from a square with no black pawn.")

            outputString = main.execute("f5f5").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "no black pawn at f5", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after trying to make a move from a square with no black pawn.")

            outputString = main.execute("d7d8").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("e7e6").trim()
            pawnsBlack.remove(Pair(6, 4))
            pawnsBlack.add(Pair(5, 4))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e3e2").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("e3e1").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("e3e3").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("h2h3").trim()
            pawnsWhite.remove(Pair(1, 7))
            pawnsWhite.add(Pair(2, 7))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 prompt to play is expected.")

            outputString = main.execute("e6e6").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("e6e7").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("e6e8").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("h7h5").trim()
            pawnsBlack.remove(Pair(6, 7))
            pawnsBlack.add(Pair(4, 7))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("h3h4").trim()
            pawnsWhite.remove(Pair(2, 7))
            pawnsWhite.add(Pair(3, 7))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 prompt to play is expected.")

            outputString = main.execute("h5h4").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("exit").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "bye")
            if ( position  == -1 ) return CheckResult(false, "Exit message is expected.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun test1(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) {index -> Pair(1,index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) {index -> Pair(6,index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("a2a3").trim()
            pawnsWhite.remove(Pair(1, 0))
            pawnsWhite.add(Pair(2, 0))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 prompt to play is expected.")

            outputString = main.execute("a7a6").trim()
            pawnsBlack.remove(Pair(6, 0))
            pawnsBlack.add(Pair(5, 0))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e2e4").trim()
            pawnsWhite.remove(Pair(1, 4))
            pawnsWhite.add(Pair(3, 4))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 prompt to play is expected.")

            outputString = main.execute("e7e5").trim()
            pawnsBlack.remove(Pair(6, 4))
            pawnsBlack.add(Pair(4, 4))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("exit").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "bye")
            if ( position  == -1 ) return CheckResult(false, "Exit message is expected.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun test2(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) {index -> Pair(1,index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) {index -> Pair(6,index) }
            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e2d3").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("e2f3").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("e3e4").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "no white pawn at e3", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after trying to make a move from a square with no white pawn.")

            outputString = main.execute("d7d8").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "no white pawn at d7", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after trying to make a move from a square with no white pawn.")

            outputString = main.execute("e2e3").trim()
            pawnsWhite.remove(Pair(1, 4))
            pawnsWhite.add(Pair(2, 4))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 prompt to play is expected.")

            outputString = main.execute("b6b5").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "no black pawn at b6", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after trying to make a move from a square with no black pawn.")

            outputString = main.execute("a2a1").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "no black pawn at a2", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after trying to make a move from a square with no black pawn.")

            outputString = main.execute("e7e6").trim()
            pawnsBlack.remove(Pair(6, 4))
            pawnsBlack.add(Pair(5, 4))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e3e5").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")

            outputString = main.execute("h2h3").trim()
            pawnsWhite.remove(Pair(1, 7))
            pawnsWhite.add(Pair(2, 7))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 prompt to play is expected.")

            outputString = main.execute("e6e4").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid command.")


            outputString = main.execute("exit").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "bye")
            if ( position  == -1 ) return CheckResult(false, "Exit message is expected.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun test3(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) {index -> Pair(1,index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) {index -> Pair(6,index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e2e4").trim()
            pawnsWhite.remove(Pair(1, 4))
            pawnsWhite.add(Pair(3, 4))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 prompt to play is expected.")

            outputString = main.execute("d7d5").trim()
            pawnsBlack.remove(Pair(6, 3))
            pawnsBlack.add(Pair(4, 3))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e4d5").trim()
            pawnsBlack.remove(Pair(4, 3))
            pawnsWhite.remove(Pair(3, 4))
            pawnsWhite.add(Pair(4, 3))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after capture move.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 prompt to play is expected.")

            outputString = main.execute("c7c6").trim()
            pawnsBlack.remove(Pair(6, 2))
            pawnsBlack.add(Pair(5, 2))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("a2a4").trim()
            pawnsWhite.remove(Pair(1, 0))
            pawnsWhite.add(Pair(3, 0))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 prompt to play is expected.")

            outputString = main.execute("c6d5").trim()
            pawnsWhite.remove(Pair(4, 3))
            pawnsBlack.remove(Pair(5, 2))
            pawnsBlack.add(Pair(4, 3))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after capture movev.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("exit").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "bye")
            if ( position  == -1 ) return CheckResult(false, "Exit message is expected.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun test4(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) {index -> Pair(1,index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) {index -> Pair(6,index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e2e4").trim()
            pawnsWhite.remove(Pair(1, 4))
            pawnsWhite.add(Pair(3, 4))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 prompt to play is expected.")

            outputString = main.execute("a7a6").trim()
            pawnsBlack.remove(Pair(6, 0))
            pawnsBlack.add(Pair(5, 0))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e4e5").trim()
            pawnsWhite.remove(Pair(3, 4))
            pawnsWhite.add(Pair(4, 4))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 prompt to play is expected.")

            outputString = main.execute("d7d5").trim()
            pawnsBlack.remove(Pair(6, 3))
            pawnsBlack.add(Pair(4, 3))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e5d6").trim()
            pawnsBlack.remove(Pair(4, 3))
            pawnsWhite.remove(Pair(4, 4))
            pawnsWhite.add(Pair(5, 3))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after en passant capture.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 prompt to play is expected.")

            outputString = main.execute("exit").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "bye")
            if ( position  == -1 ) return CheckResult(false, "Exit message is expected.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun test5(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) {index -> Pair(1,index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) {index -> Pair(6,index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e2e4").trim()
            pawnsWhite.remove(Pair(1, 4))
            pawnsWhite.add(Pair(3, 4))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 prompt to play is expected.")

            outputString = main.execute("a7a6").trim()
            pawnsBlack.remove(Pair(6, 0))
            pawnsBlack.add(Pair(5, 0))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e4e5").trim()
            pawnsWhite.remove(Pair(3, 4))
            pawnsWhite.add(Pair(4, 4))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 prompt to play is expected.")

            outputString = main.execute("d7d5").trim()
            pawnsBlack.remove(Pair(6, 3))
            pawnsBlack.add(Pair(4, 3))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("h2h3").trim()
            pawnsWhite.remove(Pair(1, 7))
            pawnsWhite.add(Pair(2, 7))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 prompt to play is expected.")

            outputString = main.execute("h7h6").trim()
            pawnsBlack.remove(Pair(6, 7))
            pawnsBlack.add(Pair(5, 7))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after 1 square move.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e5d6").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "invalid input", "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Incorrect output after an invalid en passant capture.")

            outputString = main.execute("exit").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "bye")
            if ( position  == -1 ) return CheckResult(false, "Exit message is expected.")

            return CheckResult.correct()
        }

    }

    fun checkChessboard(outputString: String, searchPos: Int, pawnsWhite: List<Pair<Int, Int>>, pawnsBlack: List<Pair<Int, Int>>): Int {
        fun createChessboardStringList(pawnsWhite: List<Pair<Int, Int>>, pawnsBlack: List<Pair<Int, Int>>): List<String> {
            var chessboard = "  +---+---+---+---+---+---+---+---+\n"
            for (i in 7 downTo 0) {
                chessboard += "${i + 1} |"
                for (j in 0..7) {
                    val square = when {
                        pawnsWhite.contains(Pair(i, j)) -> 'W'
                        pawnsBlack.contains(Pair(i, j)) -> 'B'
                        else -> ' '
                    }
                    chessboard += " $square |"
                }
                chessboard += "\n  +---+---+---+---+---+---+---+---+\n"
            }
            chessboard += "    a   b   c   d   e   f   g   h\n"
            return chessboard.trim().split("\n").map { it.trim() }
        }
        val chessboardStringList = createChessboardStringList(pawnsWhite, pawnsBlack)
        return checkOutput(outputString, searchPos, * chessboardStringList.toTypedArray())
    }

    fun checkOutput(outputString: String, searchPos: Int, vararg checkStr: String): Int {
        var searchPosition = searchPos
        for (str in checkStr) {
            val findPosition = outputString.indexOf(str, searchPosition)
            if (findPosition == -1) return -1
            if ( outputString.substring(searchPosition until findPosition).isNotBlank() ) return -1
            searchPosition = findPosition + str.length
        }
        return searchPosition
    }


  learner_created: false
feedback_link: https://hyperskill.org/projects/182/stages/925/implement#comment
status: Solved
record: 2
